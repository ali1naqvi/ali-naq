// --- Rendering & timing ---
this.animationId = null;
this.lastTime = performance.now();
this.accumGrid = 0;          // accumulator for grid steps
this.accumTerrain = 0;       // accumulator for mountain parallax
this.maxAge = 10;            // cells auto-die after this many steps to prevent messy growth
this.gridStepMs = 180;       // grid update cadence (slightly slower)
this.mountainStepMs = 40;    // mountain shift update (~25 FPS)

this.maxInitRetries = 50; // retry longer in case the section renders late

// Mountains
this.mountainLayers = [];
this.mountainPhase = null;

initMountains() {
  // Build layered mountain profiles (foreground to background)
  const h = this.canvas.height;

  const paletteDark = [
    'rgba(20, 30, 60, 0.95)',
    'rgba(26, 38, 74, 0.92)',
    'rgba(32, 46, 88, 0.90)',
    'rgba(44, 60, 110, 0.88)'
  ];
  const paletteLight = [
    'rgba(180, 200, 220, 0.95)',
    'rgba(165, 190, 215, 0.92)',
    'rgba(150, 180, 210, 0.90)',
    'rgba(140, 170, 200, 0.88)'
  ];
  const pal = this.isDarkMode ? paletteDark : paletteLight;

  this.mountainLayers = [
    { amp: h * 0.08, base: h * 0.62, freq: 0.008, speed: 0.0007, color: pal[0] },
    { amp: h * 0.10, base: h * 0.72, freq: 0.010, speed: 0.0005, color: pal[1] },
    { amp: h * 0.12, base: h * 0.82, freq: 0.012, speed: 0.00035, color: pal[2] },
    { amp: h * 0.16, base: h * 0.90, freq: 0.014, speed: 0.00025, color: pal[3] }
  ];
  this.mountainPhase = new Float32Array(this.mountainLayers.length);
  for (let i = 0; i < this.mountainPhase.length; i++) {
    this.mountainPhase[i] = Math.random() * Math.PI * 2;
  }
}

drawMountains() {
  const w = this.canvas.width;
  const h = this.canvas.height;

  for (let i = 0; i < this.mountainLayers.length; i++) {
    const L = this.mountainLayers[i];
    const phase = this.mountainPhase[i];

    this.ctx.beginPath();
    this.ctx.moveTo(0, h);

    // sample the profile at regular steps
    const step = Math.max(2, Math.floor(w / 200));
    for (let x = 0; x <= w; x += step) {
      const y0 = Math.sin(x * L.freq + phase);
      const y1 = Math.sin(x * L.freq * 2.1 + phase * 1.7) * 0.35;
      const y2 = Math.sin(x * L.freq * 3.7 + phase * 2.3) * 0.15;
      const y = L.base - L.amp * (
        0.60 * (y0 * 0.5 + 0.5) +
        0.25 * (y1 * 0.5 + 0.5) +
        0.15 * (y2 * 0.5 + 0.5)
      );
      this.ctx.lineTo(x, y);
    }

    this.ctx.lineTo(w, h);
    this.ctx.closePath();
    this.ctx.fillStyle = L.color;
    this.ctx.fill();
  }
}

clear() {
  const w = this.canvas.width;
  const h = this.canvas.height;
  // Solid light, light blue background (same in dark/light themes)
  this.ctx.fillStyle = 'rgba(234, 246, 255, 1)';
  this.ctx.fillRect(0, 0, w, h);
}

animate() {
  // Ensure canvas is visible once animation starts
  if (this.canvas && !this.canvas.classList.contains('ready')) {
    this.canvas.classList.add('ready');
  }

  const now = performance.now();
  const dt = now - this.lastTime;
  this.lastTime = now;

  this.accumGrid += dt;
  this.accumTerrain += dt;

  this.clear();

  // Update & draw mountains (parallax)
  if (this.accumTerrain >= this.mountainStepMs) {
    const steps = Math.floor(this.accumTerrain / this.mountainStepMs);
    this.accumTerrain -= steps * this.mountainStepMs;
    for (let i = 0; i < this.mountainPhase.length; i++) {
      this.mountainPhase[i] += this.mountainLayers[i].speed * steps * this.mountainStepMs;
    }
  }
  this.drawMountains();

  // Update CA grid at fixed cadence
  if (this.accumGrid >= this.gridStepMs) {
    const steps = Math.floor(this.accumGrid / this.gridStepMs);
    this.accumGrid -= steps * this.gridStepMs;
    for (let s = 0; s < steps; s++) this.updateGrid();
  }
  this.drawGrid();

  this.animationId = requestAnimationFrame(() => this.animate());
}

init() {
  this.initMountains();
}

setupResize() {
  // ... other resize logic ...
  this.initMountains();
}

setupThemeObserver() {
  const observer = new MutationObserver(() => {
    this.clear();
    this.initMountains();
  });
  // ... observer setup ...
}

initStarfield() {
  // ... existing code ...
  if (section) return;

  console.info('Mountains canvas ready:', !!canvas, 'in section:', !!section);

  try {
    // ... existing code ...
  } catch(e) {
    // ... existing code ...
  }
}
